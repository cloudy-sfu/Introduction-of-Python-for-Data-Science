# 2.1. 程序的基本结构

在Spyder中新建一个文本文件，以文件扩展名.py结尾，在文本文件中输入

```
print(“Hello world!”)
```

这就是一个最基本的Python程序。输出结果是

```
Hello world!

Program exit with code 0.
```

有些调试器不会显示Program exit with code 0. 这句话说明程序正常运行结束，如果返回值为1说明遇到错误，一同返回的还有Traceback. 如果返回值为2则说明找不到文件，通常发生在使用SSH连接远程服务器时，请排查你的文件映射配置文件。如果返回值是一个很大的整数，通常代表宕机或内存不足（很少遇到，在更专业的程序设计教材中通常会讲述）。

{% hint style="info" %}
与C/Fortran等更传统的语言不同的是，Python的特性在于前人已经实现了几乎所有可能用到的基本功能，所以当需要实现的功能时，应首先在互联网上搜索已经实现的函数库。读完本书时，你已经掌握了Python语言的特性和各种语句的用法，如果你遇到了本书没有讲到的函数，请你发挥自学能力，积极在互联网上搜索解决方案。推荐参考Stack Overflow论坛，其中有很多面向初学者的问题和回答以供参阅。
{% endhint %}

关于退出码为1的情况，接下来我们详细讲解一下Python的错误处理机制。当发生错误时，解释器会返回一个错误报告，被称为Traceback，格式如下：

```
Traceback (most recent call last):
  File "main.py", line 15, in <module>
  File "json\__init__.py", line 293, in load
  File "json\__init__.py", line 346, in loads
  File "json\decoder.py", line 337, in decode
  File "json\decoder.py", line 353, in raw_decode
json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 50 (char 49)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "main.py", line 20, in <module>
NameError: name 'exit' is not defined

```

由于我们没有学习Json函数库，所以这段程序不太容易理解，但我们必须引发一个稍复杂一点的错误，才能体现出Traceback的完整结构，所以选择了这段程序。我们没有必要理解其中的内容，事实上这是一段解析json配置文件的程序，我们将json文件中的一个必要的符号删除了，从而引发了解析错误。

排查Traceback的方法是从下往上看，在Traceback中的末尾引发了NameError，其中详细解释道exit没有被定义，而事实上exit是Python标准函数，作用是退出程序。向上一行，我们可以看到错误发生在第20行，我们给出程序的第20行：

```
exit(0)
```

这是一个退出程序的语句，并且实际上编写正确，不应是触发错误的源头。于是我们继续往上看Traceback的中间，这里提到错误是在处理上一个错误时引发的，因此需要继续看第一块输出内容，即`json.decoder.JSONDecodeError`. 根据错误描述可知，这是Json文件的数据格式错误，位置是第1行的第49个字符。在Traceback中，再向上的5行都在列举错误发生的位置，后4行都发生在json文件夹中的某个文件里，这其实是json函数库里的文件而不是开发者编写的文件。一般来说，我们不应该修改函数库中的文件，而只能修改自己编写的文件，此处错误应定位到main.py文件的第15行。这即是需要修改的地方。既然问题是Json文件的数据格式错误，因此我们就需要添加一个语句，检查Json文件的规范性；或添加一个语句，当解析错误时作其他收尾操作，并且提前结束程序。

{% hint style="info" %}
Python的退出码遵循C语言的规范，如果你有一台Linux计算机，可以在以下文件中看到更详细的退出码的含义

```
vim /usr/include/asm-generic/errno.h
vim /usr/include/asm-generic/errno-base.h
```
{% endhint %}

Python语句的结尾不需要任何标点符号，Python解释器读到一行结束，就认为是一个命令的结束和下一个命令的开始。既然，Python语言不需要添加分号，所以也不能将多行程序合并到一行中。不过Python考虑到了C语言开发者的习惯，如果在编程时输入分号，以及在分号后继续写下一行程序，解释器会自动纠正，也不会引发错误。

另外Python是脚本语言，所以不需要一个主函数，直接在脚本中写入程序语句即可。

{% hint style="info" %}
脚本是本节开头创建的文本文件，当在其中写入程序语句并且将文件输入给解释器时，它就具有了控制程序运行的功能，称之为脚本。脚本的文件扩展名被修改后，依然不影响运行，这个扩展名只是为了提醒用户，它是某种程序语言专属的脚本。
{% endhint %}

在Python语言的标准语句之外，前人们将一些复杂的功能（甚至是用其他程序语言编写的功能）封装成为函数库，放在pypi源上供公开下载。安装Python时也内置了一些常用的函数库，例如处理数学计算的math，处理操作系统的os, sys，处理文本的string, json，处理二进制文件的pickle. 在安装Python的部分，我们已经学习了安装函数库，那么我们如何将函数库导入脚本？

{% hint style="info" %}
**封装：**隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。
{% endhint %}

例如我们想要计算一个变量的sin()三角函数的计算结果，基于数学上的直觉，我们编写一条语句：

```
y = sin(x)
```

这是Python语言中的赋值语句，其中x, y是变量，sin是函数。然而sin函数并未被Python的标准库定义。事实上这个函数包含在math函数库中，所以我们以此为例讲述如何导入和使用math函数库。

{% hint style="info" %}
科学的程序设计教材应该从基本概念开始讲起，例如变量和函数在计算机中具体是什么概念。但是本教材的定位是面向没有编程基础的学生，将Python语言快速应用于量化投资实务，且有授课课时的限制。因此我们不再展开讲述基本概念的定义，而从应用讲起。希望系统学习编程思想的学生，可以参考《C语言程序设计现代方法.第2版》这本书，通常来说编程思想应从C语言学起，一些概念在程序语言之间是通用的并且可溯源的。
{% endhint %}

导入函数库的第1种写法是

```
import math

y = math.sin(x)
```

在脚本的开头写一个import语句，导入的函数库接在后面。如果要一次性导入多个函数库，既可以连续写多条import语句，也可以以逗号隔开一次性导入多个函数库，例如

```
import math, string
```

而在使用时sin被写作了math.sin，其中点号表示寻找，即从math模块中找到sin函数并且使用它。有时候函数库的名字很长，我们可以在导入时为它起一个别名，用法是

```
import math as m

y = m.sin(x)
```

{% hint style="info" %}
Python是一种高度面向对象的语言，严格来说一切数值、函数、模块都属于一个“类”，而变量是“类”的一个实例。在这里导入的math模块是module类的一个实例，sin函数是模块中的一个函数，也是module类的一个方法。现在我们还没有学习到“类”，因此我们记忆函数导入的用法即可，而不必深究原理。你现在可能会畏惧编程语言的复杂性，觉得需要记忆很多用法，但是当你学习完毕并且熟练应用之后，会越来越看到程序语句的统一性，到时候一切语法都可以化归到少数几种本质上的操作。至于为什么不在一开头就介绍“类”的概念，是因为程序语言的设计是自上而下的，设计Python语言的科学家已经是一个精通C语言的开发者，对程序有本质上的理解，因此才能设计出统一而优美的结构。初学者如果一开始就按照这种设计哲学的路径去学习，会觉得更加抽象和难以理解。相比之下，本书选择一种循序渐进的路径，先使得你记忆一些用法，实现一些功能；再通过改写的形式把它们连接成一个统一的图景。
{% endhint %}

{% hint style="info" %}
**语法糖：**指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。 语法糖让程序更加简洁，有更高的可读性。

我们已经看到了`print(`"`Hello world")`语句，导入语句import是一种语法糖，和print本质是相似的，其实import语句的本质形式是

```
math = __import__("math")
```

即\_\_import\_\_的功能是从python虚拟环境中执行…/envs/site-packages/math/\_\_init\_\_.py脚本的内容，并且把函数库math/目录软链接（在文件索引中添加，但不真正复制）到当前脚本所在目录下的math/目录。然后输出一个module类的实例，即变量math.

如果导入语句起了别名m之后，这条语句的本质性是就变成了

```
m = __import__(“math”)
```

显然这样的语句更加抽象且繁琐，会降低编程效率。所以Python做了许多的语法糖，将这些语句简化成import这样的语句。通常来说开发者不需要了解这些知识，但有时候却又意想不到的作用，例如在百度云计算平台刚上线的时候，曾经为了推广自家的paddlepaddle模块，而不允许用户使用具有相似功能的Google研发的tensorflow模块。他们匹配并忽略用户脚本中的import tensorflow语句，然而一些开发者发现`name = __import__("tensorflow")`语句没有被跳过执行，得以导入tensorflow模块。
{% endhint %}

导入函数库的第2种方法是

```
from math import sin

y = sin(x)
```

这时候sin被作为一个单独的函数导入到内存空间中，它的优点是引用时不再需要从math模块，而缺点是需要使用其他函数时，应该改写导入语句。同样地，引用多个函数（或子模块，在numpy使用部分将会详细解释）或起别名都是可行的。

{% hint style="info" %}
注意，起别名的语句只能导入一个函数或模块，导入多个函数或模块的语句不能起别名。
{% endhint %}

导入函数库的第3种用法是

```
from math import *
```

这条语句表示将math函数库中的所有函数都导入到内存空间中，解决了上面一种用法“需要使用其他函数时，应该改写导入语句”的缺点，但是引入了另一个问题：如果你定义的变量中存在sin这个名字，则在定义这个变量之后的语句中，导入的sin函数就失效了，而sin指代这个定义的变量。如果其他函数库中有同名的函数，则最终sin的内容是最后一个同名函数的内容（取决于import语句的顺序）。这种用法下不能在一条语句中导入多个模块，或为模块取别名。

所以，我们需要综合考虑函数的使用频次、普遍性、需要导入的函数库数量，决定使用哪种方法。规范来说，如果我们只引入1个函数库（不引入其他库，或其他库全都是以方法2导入的），并且仅当这个函数库里的许多函数和子模块频繁地被使用时，这个函数库可以用方法3导入。如果一个函数库中，我们只需使用其中一个函数，并且它的名字和实际意义非常匹配，例如math.sin函数和数学中的sin函数名字相同且意义相同，则我们通常以方法2导入。在任意其他情况下，我们都以方法1导入，而如果函数库的名字非常长，则通常使用别名。

一些复杂的函数库可能是层层嵌套的，我们可以使用索引符号“.”定位函数库中的函数。例如numpy函数库有一个random子函数库，如果我们需要使用random子函数库中的randint函数，则可以使用以下多种方法导入和引用（其中as用法可以灵活使用或取消）：

```
# 方法1导入numpy
>>> import numpy as np
>>> np.random.randint(1, 10)
# 方法2导入numpy和方法1导入random
>>> from numpy import random as r
>>> r.randint(1, 10)
# 方法2导入numpy和random
>>> from numpy.random import randint as rnt
>>> rnt(1, 10)

```

导入语句必须在所导入的任意一个函数被调用之前，根据编程规范，还要求写在`.py`文件的头部，在其他程序语句（包括没有使用到这些函数的语句）之前。

最后，我们还可以为程序添加注释，它使得人类开发者更方便阅读程序，但不会被机器执行。注释内容以`#`开头直至一行结束，既可以接在程序语句的结尾，也可以写在单独的一行。如果要写多行注释，则每行的开头都需要写`#`符号。一个简单的注释如下所示：

```
# 本程序编写于2021年

print(“Hello, world!”)  # 输出语句：你好，世界！
```


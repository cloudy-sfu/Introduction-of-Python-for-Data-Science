# 2.3. 面向对象

在“变量和表达式”这一节中，我们实现了一个计算隐含波动率的简单例子。那么，如果要在不同的地方反复计算隐含波动率，每次都编写这3行程序显得不简洁。所以，我们希望将计算隐含波动率的过程标识为一个符号，之后每次使用这个符号时，就会执行这3行程序。这个符号被称为函数，就像是一串文字的缩写。在使用函数时，我们只需要关心函数的输入、输出、功能，而不必关心函数内部的细节。在数学上，函数有3个元素，即自变量、因变量、表达式，例如

$$
y = f(x) = x^2 + \ln {1 \over x^2}, x > 0
$$

在Python语言中也定义了这个概念，其中x称为“参数”，f称为“函数名”，y称为“返回值”，函数内的语句就是函数的表达式。上述函数用Python语句可以写作如下形式：

```
import math as m

def f(x):
if x <= 0:
    return None
y = x**2 + m.ln(1 / x**2)
return y
```

其中def是固定的保留字，f是函数名字（可以自定义），x是“形式参数”（可以自定义），return是返回语句。

{% hint style="info" %}
**保留字：**编程语言中的一类语法结构。 在特定的编程语言里，这些保留字具有较为特殊的意义，并且在语言的格式说明里被预先定义。 通常，保留字包括用来支持类型系统的原始数据类型的标记，并可以用来识别诸如循环结构、语句块、条件、分支等程序结构。

所有的Python语言保留字如下所示：

```
'False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'
```
{% endhint %}

**函数名：**当一个函数被定义，在当前脚本的函数被定义之后的部分，可以通过函数名调用其中的功能；其他脚本如果导入了当前脚本，则其他脚本也能使用这个函数。函数名有以下规则：

* 不允许以2个下划线开头命名函数。这些函数有特殊的作用，例如加号等价于`__add__()`函数、等于号等价于`__equal__()`函数，将其他类型转化为字符串等价于`__str__()`函数……如果自定义了这些函数，会导致一些符号原本的功能失效，例如改变脚本中四则运算的算法。当然，在一些集合论的研究中（例如伽罗瓦域）会故意利用这个特性，改变所有数字的基础运算规则。
* 不允许以Python保留字命名函数。
* 当一个函数在导入的依赖库中已经存在时，则比较def语句和import语句的顺序：如果import语句在后则依赖库中的函数生效，如果def语句在后则自定义的函数生效。编程规范中规定import语句必须在脚本的开头，所以一般来说自定义函数会覆盖依赖库中原有的函数。
* 如果两个依赖库中的函数名称相同，比较import语句取后者生效。

以上文中我们定义的f函数为例，可以在脚本中写如下的语句使用它

```
>>> f(1)
2
```

这里的1称为“实际参数”，形式参数和实际参数的关系将在下面辨析。

**形式参数(parameter)和实际参数(argument)：**形式参数是函数输入值的占位符，即上文例子中的x. 在函数调用时传入实际参数，其值可以是任意类型的变量或数据结构，甚至可以是另外一个函数。当函数需要传入多个参数时，将它们用英文逗号隔开，在函数定义的形式参数、函数调用的实际参数处分别写入。经过命名空间转换后，函数内部语句使用形式参数运算。计算结果构建成return表达式，将数值直接赋予函数外部空间的返回值变量。

{% hint style="info" %}
**命名空间：**它表示着一个标识符的可见范围。一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。例如，设Bill是X公司的员工，工号为123，而John是Y公司的员工，工号也是123。由于两人在不同的公司工作，可以使用相同的工号来标识而不会造成混乱，这里每个公司就表示一个独立的名字空间。如果两人在同一家公司工作，其工号就不能相同了，否则在支付工资时便会发生混乱。
{% endhint %}

形式参数和实际参数的关系，一直是所有编程语言中非常难以理解的内容，我们可以用一个例子学习它们之间的关系。如果你生活在有地铁的城市，要去同城的一个很远的区，则需要同时乘坐地铁和公交。公交的站点通常更密集，所以你会步行到最近的公交站，乘坐公交到达地铁站；接着你会在地铁系统里乘坐列车，到达距离目的地最近的地铁站，回到地面上。如果把你看作一个数值，地铁系统（地下一层）看作一个函数体，你乘坐公交车的过程就相当于一个外部变量：将你赋予公交车这个变量，在函数外可被访问，而你的位置是用公交车号表示的（访问外部变量）。你从地铁站口的公交车下车，进入地铁站时，就是函数的传参过程，即外部变量作为实质参数传入函数，函数用形式参数承接实质参数的内容，变量的值被赋予到形式参数中。此时，地铁列车就相当于形式参数，你（变量的值）在函数内部运行，而你的位置用地铁列车号表示（访问内部变量）。在这个系统里，地铁公司只要以地铁为单位进行调度，而公交公司只要以公交车为单位进行调度，他们互相不需要知道对方的运行规律，但是可以把你连续地运送到指定地点。同样地，函数内外的变量运行互不干涉，外部程序通过访问实质参数的获取数值，函数内部通过访问形式参数获取数值，数值通过传参和返回的过程在函数内外转移。

函数体是一个单独的命名空间，内部的形式参数在函数外无效，性质如下：

* 变量名仅在内部有定义，则内部可以使用变量，外部不可使用。
* 变量名在内部和外部均有定义，则在内部定义语句之后，内部变量生效而外部变量不生效。函数返回后，在外部访问变量名仍然获得外部变量的值。
* 变量名仅在外部有定义，但内部使用到了变量，则外部变量的值“穿透”到内部，如果发生更改，也会影响到外部。

以上，我们就形式参数和实际参数的关系进行了讨论，并且介绍了一种最简单的实际、形式参数的匹配方法。形式参数的所有用法如表 2所示。

表 2 函数的参数分类

| 序号 | 实际参数是否必填 | 传入实际参数时，形式参数名是否必填 | 形式参数写法 | 形式参数位置 |
| -- | -------- | ----------------- | ------ | ------ |
| 1  | 是        | 否                 | r      |        |
| 2  | 否        | 否                 | r=0.02 | 在第1类之后 |
| 3  | 否        | 否                 | \*r    | 在第2类之后 |
| 4  | 否        | 是                 | \*\*r  | 在第3类之后 |

我们构建一个使用到所有形式参数的写法的函数，并且用尽可能多的方法调用这个函数，借此了解参数传递的灵活性：

```
>>> def g(a, b=1, c=1, *d, **e):
...     print(a, b, c, d, e)
...
>>> y = g(1)  # 方法[1]
1 1 1 () {}
>>> y = g(1, 2, 3)  # 方法[2]
1 2 3 () {}
>>> y = g(1, c=3, b=2)  # 方法[3]
1 2 3 () {}
>>> y = g(1, 2, 3, 6, 5)  # 方法[4]
1 2 3 (6, 5) {}
>>> y = g(1, 2, 3, 6, 5, m=7, n=8)  # 方法[5]
1 2 3 (6, 5) {'m': 7, 'n': 8}

# 错误示例
>>> y = g(1, c=3, b=2, 5, 6)  # 方法[6]
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument
```

根据表 2的定义，a属于第1类形式参数，b, c属于第2类形式参数，d数据第3类形式参数，e属于第4类形式参数。

上述例子可以体现只有a是必填项，而诸如b=1这样的定义中，1是形式参数b的默认值，当没有接收到实际参数时，会采用默认值填充形式参数。形式参数\*d和\*\*e是不定长度的参数，\*d没有接收到实际参数则默认填充为一个空元组，\*\*e没有收到实际参数则默认填充为一个空字典（元组和字典的概念将在“数据结构”中学到）。

形式参数对传入的实际参数，从左到右依次匹配，当不指定形式参数名时，b, c参数依次匹配必填参数之后的输入2, 3，也可以指定顺序，令c=3, b=2. 值得注意的是，当函数在调用时，使用“形式参数=实际参数”的格式赋值某个参数，则此参数后不能再使用直接传入实际参数的格式。因此，如果需要诸如\*d的元组格式的不定长参数，则不能通过“形式参数=实际参数”的格式改变第2类参数的顺序。

当固定参数处理完毕后，程序依次将所有直接传入实际参数的调用匹配到不定长参数的列表，其中列表的每个元素是对应的一个实际参数；将所有“形式参数=实际参数”格式的调用匹配到不定长参数的字典，其中字典的键是形式参数名（字符串格式），值是实际参数。（字典和元组的概念将在数据结构部分讲述，等到学习完后再来复习这里的不定长参数。）同样地，在传入“形式参数=实际参数”格式的参数后，不能再直接传入实际参数。

**返回语句：**在return的空格后接着的必须是表达式、变量或数值，代表这个函数的计算结果，相当于数学函数中的因变量。return语句可以省略，此时函数会返回一个特殊变量None.

{% hint style="info" %}
None也是保留字，不属于任何类型、不会输出任何字符、没有数据内容、不可进行任何操作、不代表任何含义，是唯一真正表示“空”的符号。

有些函数库也会自定义代表“空”的符号，但实际上只有None是不属于任何类型。例如numpy.nan在numpy函数库中代表不存在的值，但是numpy.nan继承自numpy的一些类型。这样做是为了避免运行出错：当发生一些诸如负数开方、分母为零、概率不在 区间的问题，Python会引发错误导致程序中断，但是如果使用numpy函数库中的函数进行计算时，遇到无法计算的结果会记作numpy.nan. 在批量计算时不会导致程序中断，使得你可以获得其他正确的结果，而又能轻易注意到一些结果没有被正确计算。

函数除了使用return返回，还可以通过assert作出断言和通过raise抛出错误。例如负数开方默认会返回复数，如果要在实数域上定义开方函数，则应写作：

```
def real_sqrt(x):
    assert x >= 0
    return x ** .5
```

上述函数在assert后接的判断语句为假，即x<0时，抛出AssertionError，而判断语句为真时继续运行程序。这个功能还可写作：

```
def real_sqrt(x):
    if x < 0:  # 条件语句, 将在 “控制结构” 部分详细介绍
        raise Exception(“被开方数需非负。”)
    return x ** .5
```

上述函数在x<0时抛出错误，错误信息中包含“被开方数需非负”，能够帮助程序的使用者更容易地确定错误原因。
{% endhint %}

特殊地，函数可以返回其本身，因此可以构建迭代。处理启动斐波那契数列的函数如下所示：

```
def sequence(a=1, b=1):
c = a + b
# 保护性限制：这2行语句是选择语句，暂时还未学习到。如果不加入这2行，
# 则函数会反复调用自身，直至整数超过64位处理器的存储上限。加入这2行
# 的作用是当c>1000时返回空值，退出迭代。
if c > 1000:
    return
# 保护性限制：语句结束
    print(f"{a} + {b} = {c}")
    return sequence(b, c)

sequence()
```

程序运行的结果是：

```
1 + 1 = 2
1 + 2 = 3
2 + 3 = 5
3 + 5 = 8
5 + 8 = 13
8 + 13 = 21
13 + 21 = 34
21 + 34 = 55
34 + 55 = 89
...
```

我们可以利用迭代功能完成不动点迭代，例如求超越方程$$x = \cos x, x \in [0, {\pi \over 2}]$$的解：

```
from math import cos

def g(x=0):
    if -1e-10 <= x - cos(x) <= 1e-10:  # x_i ?= cos(x_i)
        return x
    x = cos(x)              # x_{i+1} = cos(x_i)
    return g(x)
```

一系列关联的函数可以组成一个“类”，“类”代表具有相似功能的变量的集合。我们在前面提到，Python语言内置的str, int, float, bool类型都是一个类。要使用“类”的功能，我们首先要定义类，然后再创建类的实例。我们不需要定义Python语言内置的类，这些类已经在标准库中被定义过了。

定义一个类的基本模板如下所示：

```
class Dog:
def __init__(self, name, age):
    self.name = name      # string: dog’s name
    self.age = age        # int   : dog’s age

def information(self):
    print("The dog is named {self.name}, {self.age} years old.")
```

第一行表示类的名称。根据开发者规范，类名的首字母大写，如果一个类名由多个单词拼接而成，每个单词的首字母大写，单词之间没有下划线。

类中的函数被称为“方法”。特别地，类的每个函数的第一个形式参数都是self，名称不能修改，且不需要指定实际参数。被调用时，这个形式参数会被跳过。例如在下面所述的创建实例的过程中，有name=“Tom”, age=5的赋值过程，但是self没有对应的实际参数。

定义了类之后，可以创建类的实例，创建一个实例dog\_1的语句是：

```
>>> dog_1 = Dog(“Tom”, 5)
>>> dog_1
<__main__.Dog object at 0x7fcde8ae5a00>
```

{% hint style="info" %}
例如在x = “Hello, world!”中，x就是Python内置str类的实例，也是一个字符串变量。定义内置类型的变量与创建类的实例的语句看上去差异很大，是因为Python语言定义了语法糖，将创建类的语句简化为用双引号包含字符。这样做沿袭了其他程序设计语言的习惯，并且使得Python程序能够被简洁地书写。
{% endhint %}

\_\_init\_\_是一个特殊的方法，方法名不能够更改，不写返回值。创建实例时，如果“类”定义了\_\_init\_\_方法，则在创建实例时必须指定传入的\_\_init\_\_方法的实际参数，且\_\_init\_\_方法会运行一次。

除了初始化函数\_\_init\_\_以外，还有一些具有特殊意义的函数，名称不能更改，通常拥有语法糖：

\_\_call\_\_函数使得实例能够被当作一个函数使用：

```
# 定义
class Dog:
...

def __call__(self):
    print(f"Hello, my name is {self.name}.")
# 调用
>>> dog_1()
Hello, my name is Tom.
```

`__add__, __sub__, __mul__, __pow__`分别对应加、减、乘、乘方运算，例如

```
>>> x = 1.5
>>> x.__add__(2)
3.5
>>> x.__mul__(5)
7.5
>>> x.__pow__(2)
2.25
```

自定义的类也可以设置运算符号，使用数学符号运算，例如

```
# 定义
class Car:
def __init__(self, name, price):
    self.name = name
    self.price = price

def __add__(self, another_car):
    # 如果自定义运算符，运算类函数的返回值也是Car类，否则连加会发生错误。
    return Car("多辆汽车", self.price + another_car.price)
# 调用
>>> car_1 = Car("甲牌汽车", 7)
>>> car_2 = Car("乙牌汽车", 15)
>>> car_3 = Car("丙牌汽车", 36)
>>> all_car = car_1 + car_2 + car_3
>>> all_car.name
"多辆汽车"
>>> all_car.price
58
```

形式参数self就是实例本身，它的数值会被自动保存，且在类的不同方法中传递。在定义部分，属性形如self.name，其中 “self.”部分是固定的，属性的名字可以自定义。这里的点号代表“索引”，即在self实例中索引名为name的属性。self.name和self.age是实例的“属性”，可以被读出：

```
>>> car_1.name, car_1.price
("甲牌汽车", 7)
>>> car_2.name, car_2.price
("乙牌汽车", 15)
```

同样，属性也可以被修改：

```
car_1.name = "丁牌汽车"
```

在调用部分，类的属性可以用“实例名.属性名”的形式访问，类的方法可以用“实例名.调用函数”的形式访问。Python的内置类就定义了许多方法，例如字符串变量拥有很方便的功能：

```
>>> x1 = "Hello, world!"
>>> x1.upper()  # 将字符串中的ASCII字母全部变成大写
"HELLO, WORLD!"
>>> x1.lower()  # 将字符串中的ASCII字母全部变成小写
"hello, world!"

>>> x2 = "  (Empty)  "
>>> x2.lstrip()  # 去掉字符串开头的空格
"(Empty)  "
>>> x2.rstrip()  # 去掉字符串结尾的空格
"  (Empty)"
>>> x2.strip()  # 去掉字符串两端的空格
"(Empty)"
>>> x1.rstrip("!")  # 从字符串结尾去掉"!"字符串（如果有）
"Hello, world"
```

实例的属性也可以是另一个实例，或其他的类和实例。属性能够帮助我们制作自定义的数据结构，区分不同对象的信息。以上面的Car类为例，可以把每辆汽车的复杂信息都存储在一个类中，而不用担心对应关系会错乱。

变量的值只有赋予给属性之后才能被保存，如果Dog类的`__init__`方法是：

```
...
    def __init__(self, name, age):
        dogs_name = name
        dogs_age = age
...
```

则dogs\_name和dogs\_age的值不能被访问，在`__init__`方法执行结束后即被丢弃。

类还可以被继承，子类继承父类的所有属性和方法。假设所有的交通工具是一个Vehicle类，汽车是交通工具的一个种，即Car类是Vehicle类的子类，那么可以用类的继承定义Car类。假设所有的交通工具都必须有一个“车牌”的属性，汽车有一个额外的“行驶证号”的属性；所有的交通工具都可以查询“是否经过安全检测”的功能，但是汽车必须额外查询“行驶证是否有效”，才可以行驶。那么我们可以先定义Vehicle类，包含所有交通工具需要的属性和方法；Car类继承Vehicle类，增加“行驶证号”属性，改写“是否可以行驶”方法。Vehicle类和Car类分别定义如下：

```
class Vehicle:
def __init__(self, vehicle_id):
    self.vehicle_id = vehicle_id

def driven_permission(self) -> bool:
    # “-> bool” 表示输出类型为bool, 增加程序的易读性, 不是必须的
    checked = safety_check()  # 安全检测程序, 省略
    return checked

class Car(Vehicle):
def __init__(self, vehicle_id, license_id):
    # 这个语句是固定的, 表示执行父类的初始化程序
    super(Car, self).__init__(vehicle_id)  # 不必传入self给__init__
    self.license_id = license_id

def driven_permission(self) -> bool:
    checked_1 = safety_check()
    checked_2 = license_check()  # 行驶证检测程序, 省略
    return checked_1 and checked_2
```

此时如果创建Car类的实例，实例既包含vehicle\_id属性，也包含license\_id属性，且driven\_permission函数以子类的定义为准。

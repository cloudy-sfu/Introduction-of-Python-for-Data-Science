# 3.1. 使用Numpy计算线性代数

Numpy是专门实现线性代数计算的函数库。习惯性地，我们在导入numpy函数库时写作：

```
import numpy as np
```

这样的缩写是最流行的，遵循这个规范有利于与其他开发者交换程序时，作最少的改动即可运行。Python语言缺乏快速计算的多维数组格式，所以我们通常使用Numpy函数库提供多维数组的计算功能。创建1维数组的语句是：

```
x1 = np.array([1, 2, 3])
```

创建2维数组（矩阵）的语句是：

```
x2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
```

数组的一行或一列（即一个维度）拥有一个axis编码。在1维数组中只有1个轴，这个轴上axis=0. 在2维数组（矩阵）中有2个轴，沿着一行的方向（x2的1, 2, 3方向）上axis=1，沿着一列的方向（x2的1, 4, 7方向）上axis=0. 观察创建2维数组的语句，我们可知，程序从外向内依次创建维度，依次赋予0, 1, 2 … 的编码。在这个例子中，程序首先读到外层的列表，这个列表有3个元素，所以首先创建长度为3的axis=0维度，列表的每个元素作为axis=0上的一行；接着，每行都是一个长度维3的列表，所以创建长度为3的axis=1维度，列表的每个元素作为axis=1上的一列。

延拓到高维数组（张量），创建一个4维张量的语句是：

```
x3 = np.array([[[[1, 2], [3, 4]], [[5, 6], [7, 8]]], [[[9, 10], [11, 12]], [[13, 14], [15, 16]]]])
```

查看4维张量的形状：

```
>>> x3.shape
(2, 2, 2, 2)
```

要索引到x3中的元素7对应的位置，则需要分析这个元素处在哪个维度。首先，在axis=0维度上有2个元素，分别是1\~8和9\~16，元素7处在x3第1个元素列表中，所以axis=0上的索引号是0. 接着，在axis=1维度上有2个元素，分别是1\~4和5\~8，元素7处在第2个元素列表中，所以axis=1上的索引号是1，以此类推……最终，7的索引可被写成0,1,1,0.

```
>>> x3[0][1][1][0]
7
```

Numpy数组的索引可以被简写：上述例子可以被简写成`x3[0,1,1,0]`.

对矩阵沿着轴操作的函数，一般都有形式参数axis，例如求x2每一列的均值，可以写作：

```
>>> np.mean(x2, axis=0)
array([4, 5, 6])
```

其中axis=0表示沿着axis=0维度（一列）将数据看成一组。如果要求每一行的均值，则是沿着axis=1维度（一行）将数据看成一组，求一组数据的均值。输入一组数据，均值操作只输出1个标量，所以均值结果的维度比输入数据的维度少1维。

在练习矩阵操作时，我们经常需要生成一些简单的例子。Numpy提供了一些方法，使得我们能够快速创建数组。首先，Numpy提供了随机数模块，我们可以使用numpy.random.randint函数创建一个指定形状的随机整数数组（多次运行得到不一样的结果）：

```
>>> np.random.randint(1, 10, size=(3,3))
array([[4, 1, 4],
       [3, 4, 7],
       [1, 6, 9]])
```

访问 [https://assets.datacamp.com/blog\_assets/Numpy\_Python\_Cheat\_Sheet.pdf](https://assets.datacamp.com/blog\_assets/Numpy\_Python\_Cheat\_Sheet.pdf) ，可以得到一张包含了常见函数用法的卡片，我们从中摘录其他常见的创建数组的函数：

```
>>> a = np.zeros((3,4))   # 创建3行4列的全零矩阵
>>> b = np.ones((2,3,4), dtype=np.int16)  # 创建格式为int16的全壹矩阵
>>> c = np.arange(10,25,5)  # 创建向量[10, 15, 20]，和range函数用法相似
>>> d = np.linspace(0,2,9)  # 在[0, 2]区间（含端点）等距取9个数值组成向量
>>> e = np.full((2,2),7)  # 创建一个2行2列的矩阵，所有元素都是7
>>> f = np.eye(2)  # 创建2行2列的单位矩阵
```

Numpy函数库有一个在线文档：[https://numpy.org/doc/stable/](https://numpy.org/doc/stable/) 网页上包含了所有的Numpy函数的用法，如图 8所示。

![图 8 Numpy在线文档](<../.gitbook/assets/image (6).png>)

在左侧的搜索框中输入函数的名字，可以查到用法。例如我们查询numpy.linspace函数，则在搜索框中输入linspace，网站返回搜索结果页，如图 9所示。

![图 9 Numpy函数搜索结果页](<../.gitbook/assets/image (2).png>)

同名的函数有许多，我们需要找的是第1个搜索结果numpy.linspace，点击函数名字可以找到详细用法。详细内容页包含5个部分：基本功能，输入输出参数，相关函数(see also)，例子，可视化用法。基本功能介绍，使得我们知道函数的功能是不是我们想要的；相关函数的介绍，使得我们能够知道是不是有其他函数能实现功能，甚至是不是更好的实现方法。

输入输出参数是我们需要重点研究的。其中包括Parameters和Return两个部分，Parameters就是函数的形式参数，Parameters列表的顺序就是形式参数的顺序，我们可以使用“面向对象”部分学习到的函数用法，使用这个函数。例如linspace的第1个形式参数是start，文档中写道“linspace: array\_like”。这里的array\_like表示类似向量的变量类型，既可以是range生成器，可以是列表、元组，也可以是numpy数组。如果像第3个参数那样带有optional，则不是必填参数，文档会说明默认值。另外，Return列表则是函数的返回值，列表中的顺序就是返回值的顺序；如果标明optional，则可以不填变量来承接，optional有时候只有当Parameters的参数满足一定条件，才会输出。

例子部分和可视化部分会提供一些程序片段，帮助我们直观地理解如何使用这个函数。

接下来，我们学习数组（一维向量和二维矩阵）的四则运算。本书中，我们暂不考虑3维以上数组（张量）的外积（叉乘）运算。

值得注意的是，Python内置的列表类型不支持任何数组层面的运算，列表的加法是两个列表的拼接，列表的乘法是一个列表的复制。观察以下例子可以得到这个结论：

```
>>> [1, 2, 3] + [4]
[1, 2, 3, 4]
>>> [1, 2, 3] + 4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list
>>> [1, 2, 3] * 4
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

所以，只有Numpy的数组类型可以实现数学上定义的数组操作。我们生成4个数组，作为以下例子的基础：

```
>>> a1 = np.array([1, 2, 3])
>>> a2 = np.array([4, 5, 6])
>>> a3 = np.random.randint(1, 10, size=(3,3))
>>> a3
array([[4, 1, 4],
       [3, 4, 7],
       [1, 6, 9]])
>>> a4 = np.random.randint(1, 10, size=(3,3))
>>> a4
array([[9, 7, 9],
       [6, 1, 4],
       [3, 7, 2]])
```

对于相同维度和相同大小的数组，四则运算符号都代表标量运算，即对应位置的元素分别计算，然后填入输出矩阵的对应位置。

一维数组的例子如下：

```
>>> a1 + a2
array([5, 7, 9])
>>> a1 * a2
array([ 4, 10, 18])
>>> a1 / a2
array([0.25, 0.4 , 0.5 ])
```

矩阵乘法有内积（点乘）和外积（叉乘）两种表示：内积是对应元素相乘，而矩阵的外积是左操作数的一行上的元素，依次与右操作数的一列上的元素相乘，然后将乘积相加。使用四则运算符号时都触发内积运算，相同维度的数组作内积，会将对应位置的元素依次相乘。

二维数组（矩阵）的例子如下：

```
>>> a3 * a4
array([[36,  7, 36],
       [18,  4, 28],
       [ 3, 42, 18]])
```

如果一维数组和二维数组相乘，一维数组会被默认当作行向量使用。行向量和矩阵作内积，则矩阵的一列乘以行向量对应位置的一个标量，也就是说矩阵的一列中，所有元素的乘数相同。具体的例子如下所示：

```
>>> a1 * a3
array([[ 4,  2, 12],
       [ 3,  8, 21],
       [ 1, 12, 27]])
```

如果想要把一维数组变成列向量，则应使用如下语句：

```
>>> a1[:, np.newaxis]
array([[1],
       [2],
       [3]])
```

在输出数组的axis=0维度上，是a1中的所有元素，即axis=0维度上元素的数量和内容没有改变。在axis=1维度上，变量numpy.newaxis表示创建一个仅包含1个元素的新的维度，即将标量1, 2, 3分别改成一维数组\[1], \[2], \[3]. 这样，新创建的维度使得数组具备了行，原本a1中存在的1个维度成为了表示列的维度。

列向量与矩阵相乘，矩阵的一行乘以列向量对应位置的一个标量，也就是说矩阵的一行中，所有元素的乘数相同。具体的例子如下所示：

```
>>> a1[:, np.newaxis] * a3
array([[ 4,  1,  4],
       [ 6,  8, 14],
       [ 3, 18, 27]])
```

值得注意的是，一维数组与二维数组混合作内积运算时，元素对应的本质是复制低维操作数的元素，使之与高维数组一一对应。也就是说，如果运算符是不对称的，则左操作数的值永远在运算符左侧，右操作数的值永远在运算符的右侧。乘方就是一个操作数不对称的运算，例如以下运算中，a1与a3的顺序不同，则计算结果不同：

```
>>> a1 ** a3
array([[    1,     2,    81],
       [    1,    16,  2187],
       [    1,    64, 19683]])
>>> a3 ** a1
array([[  4,   1,  64],
       [  3,  16, 343],
       [  1,  36, 729]])
```

以上是数组内积的全部运算。

数组的外积运算需要使用numpy.dot函数，这一函数也可被简写为“@”符号。在外积运算中，一维数组可被默认看作行向量，例如一个行向量和一个列向量的外积可以写作：

```
# 简单写法
>>> a2 @ a2[:, np.newaxis]
array([77])
# 完整写法
>>> np.dot(a2, a2[:, np.newaxis])
array([77])
```

一维和二维数组可以根据线性代数的定义，实现规定的外积运算：

```
>>> a2 @ a3
array([ 37,  60, 105])
```

如果在线性代数的定义下，两个数组不可作外积，则会抛出错误：

```
>>> np.array([1, 1, 1, 1]) @ a3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 3 is different from 4)
```

每个numpy数组都有一个dtype属性，常用的有np.str, np.uint8, np.int8, np.int32, np.int64, np.float32, np.float64, np.complex64. 在以上的例子中，不指定dtype创建数组，默认会创建float64类型的数组。

其中str表示数组的每个元素存储了一个字符串，其余的数据格式都表示数值。

前缀u表示无符号，int表示整数类型，8表示数组中的元素在计算机中的字长是8 bit，即最多表示 个数值。由于uint8是无符号的，所以数值存储从0开始，最多表示到255，即一般来说存储在uint8数组中的必须是\[0, 255]区间的整数。而int8类型的第1个字节表示正负号，所以剩下7个字节最多表示128个数字。另外，既然0可以表示0，则-0可以用于表示-128，即int8类型的表示范围是\[-128, 127]区间的整数。

当存储的数值超过范围后，真正存储的数值从表示范围的最小值开始循环，例如int8类型最大的表示数值是127，如果创建表示128的int8类型的数组，则输出如下：

```
>>> np.array([128], dtype=np.int8)
array([-128], dtype=int8)
```

其中，-128是int8表示区间的第一个数，说明取值发生了循环。此处尤其要注意在整数加法时，不要超过数据类型的范围：

```
>>> np.array([127], dtype=np.int8) + 1
array([-128], dtype=int8)
```

一般来说，我们不必时刻担心取值超出范围，因为默认创建的值都属于float64类型，数值上限是$$1.80\times{10}^{308}$$；如果使用机器学习模型经常用到的float32或者傅里叶变换等计算中用到的complex64格式，则数值上限是$$3.40\times{10}^{38}$$，都足够实际使用了。另外，当int类型的数组发生除法时，Python会将它们自动转换成float64格式：

```
>>> np.array([127], dtype=np.int8) * 0.5
array([63.5])
```

由这个例子可知，不必担心因为设置了int类型而在除法时发生计算错误。

我们提到数据类型的原因，是因为我们可以在确保数据不会溢出范围的情况下，通过降低存储精度而节约内存空间。例如用默认的float32类型存储8万个样本上1000步迭代的金融实验，迭代序列会达到2GB. 而通常一张8000万像素的照片的体积远小于2GB，这是因为RGB通道的亮度值必定在0\~255范围，所以照片上颜色通道的亮度可以使用uint8格式存储，占用更少的内存空间。另外，一些数据科学模型要求float32类型的数据，了解数据格式能够帮助我们理解程序抛出的错误信息。在做通常的浮点数计算时，不推荐压缩数据类型。

改变数据类型的方法是astype，用法如下：

```
>>> a1.astype(np.uint8)
array([1], dtype=uint8)
```

另外，常用的改变数组形状的函数有repeate, resize, squeeze，统计非零元素数量的有nonzero，计算简单统计量的有min, max, argmin, argmax, mean, std, sum, var，取出对角线元素的有diagonal，计算累积和差分的有cumsum, cumprod, diff，可以通过numpy在线文档详细了解这些函数的用法。

numpy函数库中还有2个非常重要的常量：np.inf 表示无穷大，np.nan表示非数值。
